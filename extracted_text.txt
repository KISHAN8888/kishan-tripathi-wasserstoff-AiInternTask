UNIT 2  
RELATIONAL DATA MODEL AND LANGUAGE  
Relational Model (RM)  represents the database as a collection of relations. A relation is nothing 
but a table of values. Every row in the table represents a collection of related data values. These 
rows in the table denote a real -world entity or relationship.  
The table name and column names are helpful to interpret the meaning of values in each row. 
The data are represented as a set of relations. In the relational model, data are stored as tables. 
However, the p hysical storage of the data is independent of the way the data are logically 
organized.  
Some popular Relational Database management systems are:  
• DB2 and Informix Dynamic Server - IBM  
• Oracle and RDB – Oracle  
• SQL Server and Access - Microsoft  
2.1. Relational  Model Concepts  
1. Attribute:  Each column in a Table. Attributes are the properties which define a relation. 
e.g., Student, Rollno, NAME,etc.  
2. Tables  – In the Relational model the, relations are saved in the table format. It is stored 
along with its entities. A table has two properties rows and columns. Rows represent 
records and columns represent attributes.  
3. Tuple  – It is nothing but a single row of a table, which contains a single record.  
4. Relation Schema:  A relation schema represents the name of the relation with its 
attributes.  
5. Degree:  The total number of attributes which in the relation is called the degree of the 
relation.  
6. Cardinality:  Total number of rows present in the Table.  
7. Column:  The column represents the set of values for a specific attribute.  
8. Relati on instance  – Relation instance is a finite set of tuples in the RDBMS system. 
Relation instances never have duplicate tuples.  
9. Relation key  - Every row has one, two or multiple attributes, which is called relation 
key. 
10. Attribute domain  – Every attribute has some pre -defined value and scope which is 
known as attribute domain  
Table 2.1: Relational  
 
2.2. Relational Integrity Constraints  
Relational Integrity constraints in DBMS are referred to conditions which must be present for a 
valid relation. These Relational constraints in DBMS are derived from the rules in the mini -
world that the database represents.  
There are many types of Integrity Constraints in DBMS. Constraints on the Relational database 
management system is mostly divided into  three main categories are:  
1. Domain Constraints  
2. Key Constraints  
3. Referential Integrity Constraints  

4. Entity Integrity Constraint  
2.3. Domain Integrity Constraints  
Domain constraints can be violated if an attribute value is not appearing in the corresponding 
domain or it is not of the appropriate data type.  
Domain constraints specify that within each tuple, and the value of each attribute must be 
unique. This is specified as data types which include standard data types integers, real numbers, 
characters, Boolean s, variable length strings, etc.  
Example:  
Create DOMAIN CustomerName  
CHECK (value not NULL)  
The example shown demonstrates creating a domain constraint such that CustomerName is not 
NULL  
 
Key Constraints  
An attribute that can uniquely identify a tuple in a relation is called the key of the table. The 
value of the attribute for different tuples in the relation has to be unique.  
Example:  
In the given table, CustomerID is a key attribute of Customer Table. It  is most likely to have a 
single key for one customer, CustomerID =1 is only for the CustomerName =" Google".  
Table 2.2  
CustomerID  CustomerName  Status  
1 Google  Active  
2 Amazon  Active  
3 Apple  Inactive  
2.4. Entity integrity constraints  
o The entity integrity constraint states that primary key value can't be null.  
o This is because the primary key value is used to identify individual rows in relation and if 
the primary key has a null value, then we can't identify those rows.  
o A table can contain a null v alue other than the primary key field.  
Example:  
Table 2.3  
 
Relational database systems are expected to be equipped with a query language that can assist its 
users to query the database instances. There are two kinds of query languages − relational 
algebra and relational calculus.  
2.5. Referential Integrity Constraints  
Referential Integrity constraints in DBMS are based on the concept of Foreign Keys. A foreign 
key is an important attribute of a relation which should be referred to in othe r relationships. 
Referential integrity constraint state happens where relation refers to a key attribute of a different 
or same relation. However, that key element must exist in the table.  
Example:     Table 2.4  

 
In the above example, we have 2 relations, Customer and Billing.  
Tuple for CustomerID =1 is referenced twice in the relation Billing. So we know 
CustomerName=Google has billing amount $300  
2.6. Relational Algebra  
Relational algebra is a procedural query language, which takes instances of relations as input 
and yields instances of relations as output. It uses operators to perform queries. An operator can 
be either  unary  or binary . They accept relations as their input and yield relations as their 
output. Relational algebra is performed recursively on a relation and intermediate results are 
also considered relations.  
The fundamental operations of relational algebra are as follows −  
• Select  
• Project  
• Union  
• Set different  
• Cartesian product  
• Rename  

We will discuss all these operations in the following sections.  
Select Operation (σ)  
It selects tuples that satisfy the given predicate from a relation.  
Notation  − σ p(r) 
Where  σ stands for selection predicate and  r stands for relation.  p is prepositional logic formula 
which may use connectors like  and, or,  and not. These terms may use relational operators like 
− =, ≠, ≥, < ,  >,  ≤. 
For example  − 
σsubject = "database" (Books)  
Output  − Selects tuples from books where subject is 'database'.  
σsubject  = "database" and price = "450" (Books)  
Output  − Selects tuples from books where subject is 'database' and 'price' is 450.  
σsubject = "database" and price = "450" or year > "2010" (Books)  
Output  − Selects tuples from books where subject is 'database' and 'pr ice' is 450 or those books 
published after 2010.  
Project Operation (∏)  
It projects column(s) that satisfy a given predicate.  
Notation − ∏ A1, A2, An (r) 
Where A 1, A2 , An are attribute names of relation  r. 
Duplicate rows are automatically eliminated, as rel ation is a set.  
For example  − 
∏subject, author  (Books)  
Selects and projects columns named as subject and author from the relation Books.  
Union Operation ( ∪) 
It performs binary union between two given relations and is defined as −  
r ∪ s = { t | t ∈ r or t ∈ s} 
Notation  − r U s  
Where  r and s are either database relations or relation result set (temporary relation).  
For a union operation to be valid, the following conditions must hold −  
• r, and  s must have the same number of attributes.  
• Attribute domains must be compatible.  
• Duplicate tuples are automatically eliminated.  
∏ author (Books) ∪ ∏ author (Articles)  
Output  − Projects the names of the authors who have either written a book or an article or both.  
Set Difference (−)  
The result of set  difference operation is tuples, which are present in one relation but are not in 
the second relation.  
Notation  − r − s 
Finds all the tuples that are present in  r but not in  s. 
∏ author (Books) − ∏ author (Articles)  
Output  − Provides the name of authors who have written books but not articles.  
Cartesian Product (Χ)  
Combines information of two different relations into one.  
Notation  − r Χ s  
Where  r and s are relations and their output will be defined as −  
r Χ s = { q t | q ∈ r and t ∈ s} 
σauthor = 'roopam’ (Books Χ Articles)  
Output  − Yields a relation, which shows all the books and articles written by roopam.  
Rename Operation (ρ)  
The results of relational algebra are also relations but without any name. The rename operation 
allows us to rena me the output relation. 'rename' operation is denoted with small Greek 
letter  rho ρ. 
Notation  − ρ x (E) 
Where the result of expression  E is saved with name of  x. 
Additional operations are −  
• Set intersection  
• Assignment  
• Natural join  
2.7. Relational Calculus  
In contrast to Relational Algebra, Relational Calculus is a non -procedural (Declerative)  query 
language, that is, it tells what to do but never explains how to do it.  
Relational calculus exists in two forms −  
Tuple Relational Calculus (TRC)  
Filteri ng variable ranges over tuples  
Notation  − {T | Condition}  
Returns all tuples T that satisfies a condition.  
For example  − 
{ T.name |  Author(T) AND T.article = 'database' }  
Output  − Returns tuples  with 'name' from Author who has written article on 'database'.  
TRC can be quantified. We can use Existential ( ∃) and Universal Quantifiers ( ∀). 
For example  − 
{ R| ∃T   ∈ Authors(T.article='database' AND R.name=T.name)}  
Output  − The above query will yield the same result as the previous one.  
Domain Relational Calculus (DRC)  
In DRC, the filtering variable uses the domain of attributes instead of entire tuple values (as 
done in TRC, mentioned above).  
Notation  − 
{ a1, a2, a3, ..., a n | P (a 1, a2, a3, ... ,a n)} 
Where a1, a2 are attributes and  P stands for formulae built by inner attributes.  
For example  − 
{< article, page, subject > | ∈ Ram ∧ subject = 'database'}  
Output  − Yields Article, Page, and Subject from the relation Ram, where subject is database.  
Just like TRC, DRC can also be written using existential and universal quantifiers. DRC also 
involves relational operators.  
The expression power of Tuple Relation Calculus and Domain Relation Calculus is equivalent 
to Relational Algebra.  
 
2.8. Introduction on S QL 
SQL is a standard language for accessing and manipulating databases.  
What is SQL?  
• SQL stands for Structured Query Language  
• SQL lets you access and manipulate databases  
• SQL became a standard of the American National Standards Institute (ANSI) in 1986, 
and of the International Organization for Standardization (ISO) in 1987  
What Can SQL do?  
• SQL can execute queries against a database  
• SQL can retrieve data from a database  
• SQL can insert records in a database  
• SQL can update records in a database  
• SQL can delete records from a database  
• SQL can create new databases  
• SQL can create new tables in a database  
• SQL can create stored procedures in a database  
• SQL can create views in a database  
• SQL can set permissions on tables, procedures, and views  
2.8.1. Characteristics of SQL  
o SQL is easy to learn.  
o SQL is used to access data from relational database management systems.  
o SQL can execute queries against the database.  
o SQL is used to describe the data.  
o SQL is used to define the data in the database and manipulate it when needed.  
o SQL is used to create and drop the database and table.  
o SQL is used to create a view, stored procedure, function in a database.  
o SQL allows users to set permissions on tables, procedures, and views.  
Advantages of SQL  
There are t he following advantages of SQL:  
High speed  
Using the SQL queries, the user can quickly and efficiently retrieve a large amount of records 
from a database.  
No coding needed  
In the standard SQL, it is very easy to manage the database system. It doe sn't require a 
substantial amount of code to manage the database system.  
Well defined standards  
Long established are used by the SQL databases that are being used by ISO and ANSI.  
Portability  
SQL can be used in laptop, PCs, server and even some mobile phon es. 
Interactive language  
SQL is a domain language used to communicate with the database. It is also used to receive 
answers to the complex questions in seconds.  
Multiple data view  
Using the SQL language, the users can make different views of the database structure.  
2.8.2. SQL Data Types and Literals  
SQL Data Type is an attribute that specifies the type of data of any object. Each column, 
variable and expression has a related data type in SQL. You can use these data types while 
creating your tables. You can choose a data type for a table column based on your requirement.  
SQL Server offers six categories of data types for your use which are listed below −  
Table 2.5 : Exact Numeric Data Types  
DATA TYPE  FROM  TO 
Bigint  -9,223,372,036,854,775,808  9,223,372,036,854,775,807  
Int -2,147,483,648  2,147,483,647  
Smallint  -32,768  32,767  
Tinyint  0 255 
Bit 0 1 
Decimal  -10^38 +1  10^38 -1 
Numeric  -10^38 +1  10^38 -1 
Money  -922,337,203,685,477.5808  +922,337,203,685,477.5807  
Smallmoney  -214,748.3648  +214,748.3647  
Approximate Numeric Data Types  
 
Table 2.6 :Approximate Numeric Data Types  
DATA TYPE  FROM  TO 
Float  -1.79E + 308  1.79E + 308  
Real -3.40E + 38  3.40E + 38  
Date and Time Data Types  
Table 2.7:Date and Time Data Types  
DATA TYPE  FROM  TO 
datetime  Jan 1, 1753  Dec 31, 9999  
smalldatetime  Jan 1, 1900  Jun 6, 2079  
date Stores a date like June 30, 1991  
time Stores a time of day like 12:30 P.M.  
Note  − Here, datetime  has 3.33 milliseconds accuracy where as smalldatetime has 1 minute 
accuracy.  
 
Character Strings Data Types  
Table 2.8 : Character Strings Data Types  
Sr.No.  DATA TYPE & Description  
1 Char  
Maximum length of 8,000 characters.( Fixed length non-Unicode characters)  
2 Varchar  
Maximum of 8,000 characters.(Variable -length non -Unicode data).  
3 varchar(max)  
Maximum length of 2E + 31 characters, Variable -length non -Unicode data (SQL 
Server 2005 only).  
4 Text  
Variable -length non -Unicode data with a maximum length of 2,147,483,647 
characters.  
 
 
Unicode Character Strings Data Types  
Table 2.9  
Binary Data Types  
Table 2.10 : Binary Data Types  
Sr.No.  DATA TYPE & Description  
1 Binary : Maximum length of 8,000 bytes(Fixed -length binary data )  Sr.No.  DATA TYPE & Description  
1 Nchar  
Maximum length of 4,000 characters.( Fixed length Unicode)  
2 Nvarchar  
Maximum length of 4,000 characters.(Variable length Unicode)  
3 nvarchar(max)  
Maximum length of 2E + 31 characters (SQL Server 2005 only).( Variable length 
Unicode)  
4 ntext  
Maximum length of 1,073,741,823 characters. ( Variable length Unicode )  
2 Varbinary : Maximum length of 8,000 bytes.(Variable length binary data)  
3 varbinary(max) :Maximum length of 2E + 31 bytes (SQL Server 2005 only). ( Variable length 
Binary data)  
4 Image : Maximum length of 2,147,483,647 bytes. ( Variable length Binary Data)  
 
Misc Data Types  
Table 2.11 : Misc Data Types  
Sr.No.  DATA TYPE & Description  
1 sql_variant : Stores values of various SQL Server -supported data types, except text, ntext, 
and timestamp.  
2 Timestamp : Stores a database -wide unique number that gets updated every time a row gets 
updated  
3 Uniqueidentifier : Stores a globally unique identifier (GUID)  
4 Xml: Stores XML data. You can store xml instances in a column or a variable (SQL Server 
2005 only).  
5 Cursor : Reference to a cursor object  
6 Table : Stores a result set for later processing  
2.8.3. SQL Commands  
o SQL commands are instructions. It is used to communicate with the database. It is also 
used to perform specific tasks, functions, and queries of data.  
o SQL can perform various tasks like create a table, add data to tables, drop the table, 
modify the table, set permission fo r users.  
Types of SQL Commands  
There are five types of SQL commands: DDL, DML, DCL, TCL, and DQL.  
 
 
Figure 2.1: Types of SQL Commands  
1. Data Definition Language (DDL)  
o DDL changes the structure of the table like creating a table, deleting a table, altering a 
table, etc.  
o All the command of DDL are auto -committed that means it permanently save all the 
changes in the database.  
Here are some commands that come under DDL:  
o CREATE  
o ALTER  
o DROP  
o TRUNCATE  
a. CREATE  It is used to create a new table in the database.  
Syntax:  
CREATE  TABLE  TABLE_NAME  (COLUMN_NAME  DATATYPES[,....]);    
Example:  
CREATE  TABLE  EMPLOYEE(Name  VARCHAR2( 20), Email  VARCHAR2( 100), DOB  DAT
E);   
b. DROP:  It is used to delete both the structure and record stored in the table.  
Syntax  
DROP  TABLE  ;   

Example  
DROP  TABLE  EMPLOYEE;    
c. ALTER:  It is used to alter the structure of the database. This change could be either to modify 
the characteristics of an existing attribute or probably to add a new attribute.  
Syntax:  
To add a new column in  the table  
ALTER  TABLE  table_name  ADD  column_name  COLUMN -definition;      
To modify existing column in the table:  
ALTER  TABLE  MODIFY(COLUMN  DEFINITION....);    
EXAMPLE  
ALTER  TABLE  STU_DETAILS  ADD(ADDRESS  VARCHAR2( 20));   
ALTER  TABLE  STU_DETAILS  MODIFY  (NAME  VARCHAR2( 20));   
d. TRUNCATE:  It is used to delete all the rows from the table and free the space containing the 
table.  
Syntax:  
TRUNCATE  TABLE  table_name;    
Example:  
TRUNCATE  TABLE  EMPLOYEE;    
 
2. Data Manipulation Language  
o DML commands are used to modify the database. It is responsible for all form of changes 
in the database.  
o The command of DML is not auto -committed that means it can't permanently save all the 
changes in the database. They can be rollback.  
Here are some commands that come under DML:  
o INSERT  
o UPDATE  
o DELETE  
a. INSERT:  The INSERT statement is a SQL query. It is used to insert data into the row of a 
table.  
Syntax:  
INSERT  INTO  TABLE_NAME      
(col1,  col2,  col3,....  col N)   
VALUES  (value1,  value2,  value3,  .... valueN);    
Or 
INSERT  INTO  TABLE _NAME      
VALUES  (value1,  value2,  value3,  .... valueN);      
For example:  
INSERT  INTO  javatpoint  (Author,  Subject)  VALUES  ("Sonoo" , "DBMS" );   
b. UPDATE:  This command is used to update or modify the value of a column in the table.  
Syntax:  
UPDATE  table_name  SET [column_name1=  value1,...column_nameN  = valueN]  [WHERE  CO
NDITION]     
For example:  
UPDATE  students      
SET User_Name  = 'Sonoo'      
WHERE  Student_Id  = '3'   
c. DELETE:  It is used to remove one or more row from a table.  
Syntax:  
DELETE  FROM  table_name  [WHERE  condition];    
For example:  
DELETE  FROM  javatpoint    
WHERE  Author= "Sonoo" ;   
 
 
3. Data Control Language  
DCL commands are used to grant and take back authority from any database user.  
Here are some commands that come under DCL:  
o Grant  
o Revoke  
a. Grant:  It is used to give user access privileges to a database.  
Example  
GRANT  SELECT,  UPDATE  ON MY_TABLE  TO SOME_USER,  ANOTHER_USER;    
b. Revoke:  It is used to take back permissions from the user.  
Example  
REVOKE  SELECT,  UPDATE  ON MY_TABLE  FROM  USER1,  USER2;    
 
4. Transaction Control Language  
TCL commands can only use with DML commands like INSERT, DELETE and UPDATE only.  
These operations are automatically committed in the database that's why they cannot be used 
while creating tables or dropping th em. 
Here are some commands that come under TCL:  
o COMMIT  
o ROLLBACK  
o SAVEPOINT  
a. Commit:  Commit command is used to save all the transactions to the database.  
Syntax:  
COMMIT;    
Example:  
DELETE  FROM  CUSTOMERS    
WHERE  AGE  = 25;   
COMMIT;    
b. Rollback:  Rollback command is used to undo transactions that have not already been saved to 
the database.  
Syntax:  
ROLLBACK;    
Example:  
DELETE  FROM  CUSTOMERS    
WHERE  AGE  = 25;   
ROLLBACK;    
c. SAVEPOINT:  It is used to roll the transaction back to a certain point without rolling back the 
entire transaction.  
Syntax:  
SAVEPOINT  SAVEPOINT_NAME;    
5. Data Query Language  
DQL is used to fetch the data from the database.  
It uses only one command:  
o SELECT  
a. SELECT:  This is the same as the projection operation of relat ional algebra. It is used to select 
the attribute based on the condition described by WHERE clause.  
Syntax:  
SELECT  expressions      
FROM  TABLES      
WHERE  conditions;    
For example:  
SELECT  emp_name    
FROM  employee    
WHERE  age > 20;  
2.8.4. SQL Operators and Their Procedure  
What is an Operator in SQL?  
An operator is a reserved word or a character used primarily in an SQL statement's WHERE 
clause to perform operation(s), such as comparisons and arithmetic operations. These Operators 
are used to specify conditions in an SQL statement and to serve as conjunctions for multiple 
conditions in a statement.  
• Arithmetic operators  
• Comparison operators  
• Logical operators  
• Operators used to negate conditions  
SQL Arithmetic Operators  
Assume  'variable a'  holds 1 0 and  'variable b'  holds 20, then – 
Table  2.12: SQL Arithmetic Operators  
Operator  Description  Example  
+ (Addition)  Adds values on either side of the operator.  a + b will give 30  
- (Subtraction)  Subtracts right hand operand from left hand operand.  a - b will give -10 
* 
(Multiplication)  Multiplies values on either side of the operator.  a * b will give 200  
/ (Division)  Divides left hand operand by right hand operand.  b / a will give 2  
% (Modulus)  Divides left hand operand by right hand operand and return s 
remainder.  b % a will give 0  
SQL Comparison Operators  
Assume  'variable a'  holds 10 and  'variable b'  holds 20, then – 
Table  2.13:SQL Comparison Operators  
Operator  Description  Example  
= Checks if the values of two operands are equal or not, if yes then 
condition becomes true.  (a = b) is 
not true.  
!= Checks if the values of two operands are equal or not, if values are not 
equal then condition becomes true.  (a != b) 
is true.  
<> Checks if the values of two operands are equal or not, if values are not 
equal then condition becomes true.  (a <> b) 
is true.  
> Checks if the value of left operand is greater than the value of right 
operand, if yes then condition becomes true.  (a > b) is 
not true.  
< Checks if the value of left operand is less than the value of right 
operand, if yes then condition becomes true.  (a < b) is 
true. 
>= Checks if the value of left operand is greater than or equal to the value 
of right operand, if yes then condition becomes true.  (a >= b) 
is not 
true. 
<= Checks if the value o f left operand is less than or equal to the value of 
right operand, if yes then condition becomes true.  (a <= b) 
is true.  
!< Checks if the value of left operand is not less than the value of right (a !< b) 
operand, if yes then condition becomes true.  is false.  
!> Checks if the value of left operand is not greater than the value of 
right operand, if yes then condition becomes tr ue. (a !> b) 
is true.  
SQL Logical Operators  
Here is a list of all the logical operators available in SQL.  
Table 2.14: SQL Logical Operators  
Sr.No.  Operator & Description  
1 ALL : The ALL operator is used to compare a value to all values in another value set.  
2 AND : The AND operator allows the existence of multiple conditions in an SQL statement's 
WHERE clause.  
3 ANY : The ANY operator is used to compare a value to any applicable value in the list as per 
the condition.  
4 BETWEEN : The BETWEEN operator is used to search for values that are within a set of 
values, given the minimum value and the maximum value.  
5 EXISTS : The EXISTS operator is used to search for the presence of a row in a specified 
table that meets a certain criterion.  
6 IN: The IN operator is used to compare a value to a list of literal values that have been 
specified.  
7 LIKE : The LIKE operator is used to compare a value to similar values using wildcard 
operators.  
8 NOT : The NOT operator reverses the meaning of the logical operator with which it is used. 
Eg: NOT EXISTS, NOT BETWEEN, NOT IN, etc.  This is a negate operator.  
9 OR: The OR operator is used to combine multiple conditions in an SQL statement's WHERE 
clause.  
10 IS NULL : The NULL operator is used to compare a value with a NULL value.  
11 UNIQUE : The UNIQUE operator searches every row of a specified table for uniqueness (no 
duplicates).  
 
2.8.5. SQL Table  
Table is a collection of data, organized in terms of rows and columns. In DBMS term, table is 
known as relation and row as tuple.  
Table is the simple form of data storage. A table is also considered as a convenient 
representation of relations.  
Let's see an example of an employee table:  
Table  2.15:Example  
Employee  
EMP_NAME  ADDRESS  SALARY  
Ankit  Lucknow  15000  
Raman  Allahabad  18000  
Mike  New York  20000  
In the above table, "Employee" is the table name, "EMP_NAME", "ADDRESS" and "SALARY" 
are the column names. The combination of data of multiple columns forms a row e.g. "Ankit", 
"Lucknow" and 15000 are the data of one row.  
SQL TABLE Variable  
The SQL Table variable  is used to create, modify, rename, copy and delete tables. Table 
variable was introduced by Microsoft.  
It was introduced with SQL server 2000 to be an alternative of temporary tables.  
It is a variable where we temporary store records and res ults. This is same like temp table but in 
the case of temp table we need to explicitly drop it.  
Table variables are used to store a set of records. So declaration syntax generally looks like 
CREATE TABLE syntax.  
create  table  "tablename"   ("column1"  "data  type",   "column2"  "data  type",   ...  "columnN"  "data  
type");    
When a transaction rolled back the data associated with table variable is not rolled back.  
A table variable generally uses lesser resources than a temporary variable.  
Table variable cannot be used as an input or an output parameter.  
2.8.6. Views in database  
Views in SQL are kind of virtual tables. A view also has rows and columns as they are in a real 
table in the database. We can create a view by selecting fields from one or more tables present 
in the database. A View can either have all the rows of a table or specific rows based on certain 
condition.  
In this article we will learn about creating, deleting and updating Views.  
Sample  Tables : 
StudentDetails  
 
 
StudentMarks  

 
  
Creating  Views 
We can create View using  CREATE  VIEW  statement. A View can be created from a single 
table or multiple tables.  
Syntax : 
CREATE VIEW view_name AS  
SELECT column1, column2.....  
FROM table_name  
WHERE condition;  
view_name : Name for the View  
table_name : Name of the table  
condition : Condition to select rows  
Examples : 
• Creating  View  from  a single  table:  
• In this example we will create a View named DetailsView from the table 
StudentDetails.  
Query:  
• CREATE VIEW DetailsView AS  
• SELECT NAME, ADDRESS  
• FROM StudentDetails  
• WHERE S_ID < 5;  
To see the data in the View, we can query the view in the same manner as we 
query a table.  

SELECT * FROM DetailsView;  
Output:  
 
 
  
• In this example, we will create a view named StudentNames from the table 
StudentDetails.  
Query:  
 
 
CREATE VIEW StudentNames AS  
SELECT S_ID, NAME  
FROM StudentDetails  
ORDER BY NAME;  
If we now query the view as,  
SELECT * FROM StudentNames;  
Output:  
 
  

• Creating  View  from  multiple  tables : In this example we will create a View named 
MarksView from two tables StudentDetails and StudentMarks. To create a View from 
multiple tables we can simply include multiple tables in the SELECT statement. Query:  
• CREATE VIEW MarksView AS  
• SELECT StudentDetails.NAME, StudentDetails.ADDRESS, StudentMarks.MARKS  
• FROM StudentDetails, StudentMarks  
• WHERE StudentDetails.NAME = StudentMarks.NAME;  
To display data of View MarksView:  
SELECT * FROM MarksView;  
Output:  
 
Deleting  Views 
We have learned about creating a View, but what if a created View is not needed any more? 
Obviously we will want to delete it. SQL allows us to delete an existing View. We can delete 
or drop a View using the DROP statement.  
Syntax : 
DROP VIEW view_name;  
view_name : Name of the View which we want to delete.  
For example, if we want to delete the View  MarksView , we can do this as:  
DROP VIEW MarksView;  
 
Updating  Views 
There are certain conditions needed to be satisfied to update a view. If any one of these 
conditions is  not met, then we will not be allowed to update the view.  

1. The SELECT statement which is used to create the view should not include GROUP BY 
clause or ORDER BY clause.  
2. The SELECT statement should not have the DISTINCT keyword.  
3. The View should have all NOT NULL values.  
4. The view should not be created using nested queries or complex queries.  
5. The view should be created from a single table. If the view is created using multiple tables 
then we will not be allowed to update th e view.  
• We can use the  CREATE  OR REPLACE  VIEW  statement to add or remove fields from a 
view.  
Syntax : 
• CREATE OR REPLACE VIEW view_name AS  
• SELECT column1,coulmn2,..  
• FROM table_name  
• WHERE condition;  
For example, if we want to update the view  MarksView  and add the field AGE to this 
View from  StudentMarks  Table, we can do this as:  
 
CREATE OR REPLACE VIEW MarksView AS  
SELECT StudentDetails.NAME, StudentDetails.ADDRESS, StudentMarks.MARKS, 
StudentMarks.AGE  
FROM StudentDetails, StudentMarks  
WHERE S tudentDetails.NAME = StudentMarks.NAME;  
If we fetch all the data from MarksView now as:  
SELECT * FROM MarksView;  
Output:  
 
 
• Inserting  a row in a view : 
We can insert a row in a View in a same way as we do in a table. We can use the INSERT 
INTO statement of SQL to insert a row in a View. Syntax : 
• INSERT INTO view_name(column1, column2 , column3,..)  
• VALUES(value1, value2, value3..);  
• view_name : Name of the View  
Example : 
In the below example we will insert a new row in the View DetailsView which we have 
created above in the example of “creating views from a single table”.  
INSERT INTO DetailsView(NAME, ADDRESS)  
VALUES("Suresh","Gurgaon");  
If we fetch all the data from DetailsView now as,  
SELECT * FROM DetailsView;  
Output:  
 
 
  
• Deleting  a row from  a View : 
Deleting rows from a view is also as simple as deleting rows from a table. We can use the 

DELETE statement of SQL to delete rows from a vi ew. Also deleting a row from a view 
first delete the row from the actual table and the change is then reflected in the 
view. Syntax : 
• DELETE FROM view_name  
• WHERE condition;  
• view_name :Name  of view from where we want to delete rows  
• condition : Condition to select rows  
Example : 
In this example we will delete the last row from the view DetailsView which we just added 
in the above example of inserting rows.  
DELETE FROM DetailsView  
WHERE NAME="S uresh";  
If we fetch all the data from DetailsView now as,  
SELECT * FROM DetailsView;  
Output:  
 
  
 
 
SQL Indexes  

Indexes are  special lookup tables  that the database search engine can use to speed up data 
retrieval. Simply put, an index is a pointer to data in a table. An index in a database is very 
similar to an index in the back of a book.  
For example, if you want to reference all pages in a book that discusses a certain topic, you first 
refer to the index, which lists all the topics alphabetically and  are then referred to one or more 
specific page numbers.  
An index helps to speed up  SELECT  queries and  WHERE  clauses, but it slows down data 
input, with the  UPDATE  and the  INSERT  statements. Indexes can be created or dropped with 
no effect on the data.  
Creating an index involves the  CREATE INDEX  statement, which allows you to name the 
index, to specify the table and which column or columns to index, and to indicate whether the 
index is in an ascending or descending order.  
Indexes can also be unique, like th e UNIQUE  constraint, in that the index prevents duplicate 
entries in the column or combination of columns on which there is an index.  
The CREATE INDEX Command  
The basic syntax of a  CREATE INDEX  is as follows.  
CREATE INDEX index_name ON table_name;  
Single -Column Indexes  
A single -column index is created based on only one table column. The basic syntax is as 
follows.  
CREATE INDEX index_name  
ON table_name (column_name);  
 
Unique Indexes  
Unique indexes are used not only for performance, but also for data integrity. A unique index 
does not allow any duplicate values to be inserted into the table. The basic syntax is as follows.  
CREATE UNIQUE INDEX index_name  
on table_name (column_name);  
 
Composite Indexes  
A composite index is an index on two or more co lumns of a table. Its basic syntax is as follows.  
CREATE INDEX index_name  
on table_name (column1, column2);  
Whether to create a single -column index or a composite index, take into consideration the 
column(s) that you may use very frequently in a query's WH ERE clause as filter conditions.  
Should there be only one column used, a single -column index should be the choice. Should 
there be two or more columns that are frequently used in the WHERE clause as filters, the 
composite index would be the best choice.  
Implicit Indexes  
Implicit indexes are indexes that are automatically created by the database server when an 
object is created. Indexes are automatically created for primary key constraints and unique 
constraints.  
The DROP INDEX Command  
An index can be droppe d using SQL  DROP  command. Care should be taken when dropping an 
index because the performance may either slow down or improve.  
The basic syntax is as follows −  
DROP INDEX index_name;  
You can check the  INDEX Constraint  chapter to see some actual examples on Indexes.  
When should indexes be avoided?  
Although indexes are intended to enhance a database's performance, there are times when they 
should be avoided.  
The following guidelines indicate when the use of an index should be reconsidered.  
• Indexes should not be used on small tables.  
• Tables that have frequent, large batch updates or insert operations.  
• Indexes should not be used on columns that c ontain a high number of NULL values.  
• Columns that are frequently manipulated should not be indexed.  
2.8.7. SQL Sub Query  
A Subquery  is a query within another SQL query and embedded within the WHERE clause.  
Important Rule:  
o A subquery can be placed in a number of SQL clauses like WHERE clause, FROM 
clause, HAVING clause.  
o You can use Subquery  with SELECT, UPDATE, INSERT, DELETE statements along 
with the operators like =, <, >, >=, <=, IN, BETWEEN, etc.  
o A subquery is a query within another query. The outer query is known as the main query, 
and the inner query is known as a subquery.  
o Subqueries are on the right side of the comparison operator.  
o A subquery is enclosed in parentheses.  
o In the Subquery, ORDER BY command cannot be used. But GROUP BY command can 
be used to perform the same function as ORDER BY command.  
1. Subqueries with the Select Stat ement  
SQL subqueries are most frequently used with the Select statement.  
Syntax  
SELECT  column_name    
FROM  table_name    
WHERE  column_name  expression  operator     
( SELECT  column_name   from  table_name  WHERE  ... );   
Example  
Consider the EMPLOYEE table have th e following records:  
Table 2.16  
ID NAME  AGE  ADDRESS  SALARY  
1 John  20 US 2000.00  
2 Stephan  26 Dubai  1500.00  
3 David  27 Bangkok  2000.00  
4 Alina  29 UK 6500.00  
5 Kathrin  34 Bangalore  8500.00  
6 Harry  42 China  4500.00  
7 Jackson  25 Mizoram  10000.00  
The subquery with a SELECT statement will be:  
SELECT  *    
FROM  EMPLOYEE    
WHERE  ID IN (SELECT  ID    
FROM  EMPLOYEE     
WHERE  SALARY  > 4500 );   
This would produce the following result:  
Table 2.17  
ID NAME  AGE  ADDRESS  SALARY  
4 Alina  29 UK 6500.00  
5 Kathrin  34 Bangalore  8500.00  
7 Jackson  25 Mizoram  10000.00  
2. Subqueries with the INSERT Statement  
o SQL subquery  can also be used with the Insert statement. In the insert statement, data 
returned from the subquery is used to insert into another table.  
o In the subquery, the selected data can be modified with any of the character, date 
functions.  
Syntax:  
INSERT  INTO  table_name  (column1,  column2,  column3....)     
SELECT  *   
FROM  table_name    
WHERE  VALUE  OPERATOR    
 
Example  
Consider a table EMPLOYEE_BKP with similar as EMPLOYEE.  
Now use the following syntax to copy the complete EMPLOYEE table into the 
EMPLOYEE_BKP table.  
   INSERT  INTO  EMPLOYEE_BKP    
   SELECT  * FROM  EMPLOYEE     
   WHERE  ID IN (SELECT  ID    
   FROM  EMPLOYEE);    
3. Subqueries with the UPDATE Statement  
The subquery of SQL can be used in conjunction with the Update statement. When a subque ry is 
used with the Update statement, then either single or multiple columns in a table can be updated.  
Syntax  
UPDATE  table    
SET column_name  = new_value    
WHERE  VALUE  OPERATOR    
(SELECT  COLUMN_NAME    
 FROM  TABLE_NAME    
WHERE  condition);    
Example  
Let's as sume we have an EMPLOYEE_BKP table available which is backup of EMPLOYEE 
table. The given example updates the SALARY by .25 times in the EMPLOYEE table for all 
employee whose AGE is greater than or equal to 29.  
UPDATE  EMPLOYEE    
SET SALARY  = SALARY  * 0.25   
WHERE  AGE  IN (SELECT  AGE  FROM  CUSTOMERS_BKP    
 WHERE  AGE  >= 29);   
This would impact three rows, and finally, the EMPLOYEE table would have the following 
records.  
 Table 2. 18 
ID NAME  AGE  ADDRESS  SALARY  
1 John  20 US 2000.00  
2 Stephan  26 Dubai  1500.00  
3 David  27 Bangkok  2000.00  
4 Alina  29 UK 1625.00  
5 Kathrin  34 Bangalore  2125.00  
6 Harry  42 China  1125.00  
7 Jackson  25 Mizoram  10000.00  
4. Subqueries with the DELETE Statement  
The subquery  of SQL can be used in conjunction with the Delete statement just like any other 
statements mentioned above.  
Syntax  
1. DELETE  FROM  TABLE_NAME    
2. WHERE  VALUE  OPERATOR    
3.    (SELECT  COLUMN_NAME    
4.    FROM  TABLE_NAME    
5.    WHERE  condition);     
Example  
Let's assume w e have an EMPLOYEE_BKP table available which is backup of EMPLOYEE 
table. The given example deletes the records from the EMPLOYEE table for all EMPLOYEE 
whose AGE is greater than or equal to 29.  
DELETE  FROM  EMPLOYEE    
WHERE  AGE  IN (SELECT  AGE  FROM  EMPLOYEE _BKP    
WHERE  AGE  >= 29 );   
This would impact three rows, and finally, the EMPLOYEE table would have the following 
records.      Table 2. 18 
ID NAME  AGE  ADDRESS  SALARY  
1 John  20 US 2000.00  
2 Stephan  26 Dubai  1500.00  
3 David  27 Bangkok  2000.00  
7 Jackson  25 Mizoram  10000.00  
 
2.8.8. Aggregate functions in SQL  
In database management an aggregate function is a function where the values of multiple rows 
are grouped together as input on certain criteria to form a single value of more significant 
meaning.  
Various  Aggregate  Functions  
1) Count()  
2) Sum()  
3) Avg()  
4) Min()  
5) Max()  
Now let us understand each Aggregate function with a example:  
Id     Name     Salary  
-----------------------  
1       A        80  
2       B        40  
3       C         60 
4       D        70  
5       E        60  
6       F        Null  
 Count():  
 Count(*):  Returns total number of records .i.e 6.  
Count(salary):  Return number of Non Null values over the column salary. i.e 5.  
Count(Distinct  Salary):   Return number of distinct Non Null values over the column salary .i.e 
4 
Sum():  
  
sum(salary):   Sum all Non Null values of Column salary i.e., 310  
sum(Distinct  salary):  Sum of all distinct Non -Null values i.e., 250.  
 
Avg():  
 Avg(salary)  = Sum(salary) / count(salary) = 310/5  
Avg(Distinct  salary)  = sum(Distinct salary) / Count(Distinct Salary) = 250/4  
Min():  
Min(salary):  Minimum value in the salary column except NULL i.e., 40.  
Max(salary):  Maximum value in the salary i.e., 80.  
 
2.8.9. Insert, Update and Delete Operations in SQL  
The SQL  INSERT INTO  Statement is used to add new rows of data to a table in the 
database.There are two basic syntaxes of the INSERT INTO statement which are shown below.  
INSERT INTO TABLE_NAME (column1, column2, column3,...columnN)   
VALUES (value1, value2, value3,...valueN) ; 
Here, column1, column2, column3,...columnN are the names of the columns in the table into 
which you want to insert the data.  
You may not need to specify the column(s) name in the SQL query if you are adding values for 
all the columns of the table. But ma ke sure the order of the values is in the same order as the 
columns in the table.  
The SQL INSERT INTO  syntax will be as follows −  
INSERT INTO TABLE_NAME VALUES (value1,value2,value3,...valueN);  
Example  
The following statements would create six records in t he CUSTOMERS table.  
INSERT INTO CUSTOMERS (ID,NAME ,AGE ,ADDRESS ,SALARY ) 
VALUES (1,'Ramesh' ,32,'Ahmedabad' ,2000.00 ); 
 
INSERT INTO CUSTOMERS (ID,NAME ,AGE ,ADDRESS ,SALARY ) 
VALUES (2,'Khilan' ,25,'Delhi' ,1500.00 ); 
 
INSERT INTO CUSTOMERS (ID,NAME ,AGE ,ADDRESS ,SALARY ) 
VALUES (3,'kaushik' ,23,'Kota' ,2000.00 ); 
 
INSERT INTO CUSTOMERS (ID,NAME ,AGE ,ADDRESS ,SALARY ) 
VALUES (4,'Chaitali' ,25,'Mumbai' ,6500.00 ); 
 
INSERT INTO CUSTOMERS (ID,NAME ,AGE ,ADDRESS ,SALARY ) 
VALUES (5,'Hardik' ,27,'Bhopal' ,8500.00 ); 
INSERT INTO CUSTOMERS (ID,NAME ,AGE ,ADDRESS ,SALARY ) 
VALUES (6,'Komal' ,22,'MP',4500.00 ); 
You can create a record in the CUSTOMERS table by using the second syntax as shown below.  
INSERT INTO CUSTOMERS  
VALUES (7, 'Muffy', 24, 'Indore', 10000.00 );  
All the ab ove statements would produce the following records in the CUSTOMERS table as 
shown below.  
| ID | NAME     | AGE | ADDRESS   | SALARY   | 
|1|Ramesh |32|Ahmedabad |2000.00 | 
|2|Khilan |25|Delhi |1500.00 | 
|3| kaushik  |23|Kota |2000.00 | 
|4|Chaitali |25|Mumbai |6500.00 | 
|5|Hardik |27|Bhopal |8500.00 | 
|6|Komal |22| MP        |4500.00 | 
|7|Muffy |24|Indore |10000.00 | 
Populate one table using another table  
You can populate the data into a table through the select statement over another table; provided 
the other table has a set of fields, which are required to populate the first table.  
Here is the syntax −  
INSERT INTO first_table_name [(column1, column2, ... columnN)]  
   SELECT column1, column2, ...columnN  
   FROM second_table_name  
   [WHERE condition];  
 
 SQL UPDATE  
The SQL  UPDATE  Query is used to modify the existing records in a table. You can use the 
WHERE clause with the UPDATE query to update the selected rows, otherwise all the rows 
would be affected.  
Syntax  
The basic syntax of the UPDATE query with a WHERE clause is as follows −  
UPDATE table_name  
SET column1 = value1, column2 = value2...., columnN = valueN  
WHERE [condition];  
You can combine N number of conditions using the AND or the OR operators.  
Example  
Consider the CUSTOMERS table having the following records −  
| ID | NAME     | AGE | ADDRESS   | SALARY   | 
|1|Ramesh |32|Ahmedabad |2000.00 | 
|2|Khilan |25|Delhi |1500.00 | 
|3| kaushik  |23|Kota |2000.00 | 
|4|Chaitali |25|Mumbai |6500.00 | 
|5|Hardik |27|Bhopal |8500.00 | 
|6|Komal |22| MP        |4500.00 | 
|7|Muffy |24|Indore |10000.00 | 
The following query will update the ADDRESS for a customer whose ID number is 6 in the 
table.  
SQL > UPDATE CUSTOMERS  
SET ADDRESS ='Pune'  
WHERE ID =6; 
Now, the CUSTOMERS table would have the following records −  
| ID | NAME     | AGE | ADDRESS   | SALARY   |  
|  1 | Ramesh   |  32 | Ahmedabad |  2000.00 |  
|  2 | Khilan   |  25 | Delhi     |  1500.00 |  
|  3 | kaushik  |  23 | Kota      |  2000.00 |  
|  4 | Chaitali |  25 | Mumbai    |  65 00.00 |  
|  5 | Hardik   |  27 | Bhopal    |  8500.00 |  
|  6 | Komal    |  22 | Pune      |  4500.00 |  
|  7 | Muffy    |  24 | Indore    | 10000.00 |  
If you want to modify all the ADDRESS and the SALARY column values in the CUSTOMERS 
table, you do not need to use the WHERE clause as the UPDATE query would be enough as 
shown in the following code block.  
SQL > UPDATE CUSTOMERS  
SET ADDRESS ='Pune' , SALARY =1000.00 ; 
Now, CUSTOMERS table would have the following records −  
| ID | NAME     | AGE | ADDRESS | SALARY  | 
|  1 | Ramesh   |  32 | Pune    | 1000.00 |  
|  2 | Khilan   |  25 | Pune    | 1000.00 |  
|  3 | kaushik  |  23 | Pune    | 1000.00 |  
|  4 | Chaitali |  25 | Pune    | 1000.00 |  
|  5 | Hardik   |  27 | Pune    | 1000.00 |  
|  6 | Komal     |  22 | Pune    | 1000.00 |  
|  7 | Muffy    |  24 | Pune    | 1000.00 |  
 
 
SQL DELETE QUERY  
The SQL DELETE Query is used to delete the existing records from a table.  
You can use the WHERE clause with a DELETE query to delete the selected rows, otherwise 
all the records would be deleted.  
Syntax  
The basic syntax of the DELETE query with the WHERE clause is as follows −  
DELETE FROM table_name  
WHERE [condition];  
You can combine N number of conditions using AND or OR operators.  
Example  
Consider the C USTOMERS table having the following records −  
+----+---------- +-----+----------- +---------- + 
| ID | NAME     | AGE | ADDRESS   | SALARY   |  
+----+---------- +-----+----------- +---------- + 
|  1 | Ramesh   |  32 | Ahmedabad |  2000.00 |  
|  2 | Khilan   |  25 | Delhi     |  1500.00 |  
|  3 | kaushik  |  23 | Kota      |  2000.00 |  
|  4 | Chaitali |  25 | Mumbai    |  6500.00 |  
|  5 | Hardik   |  27 | Bhopal    |  8500.00 |  
|  6 | Komal    |  22 | MP        |  4500.00 |  
|  7 | Muffy     |  24 | Indore    | 10000.00 |  
+----+---------- +-----+----------- +---------- + 
The following code has a query, which will DELETE a customer, whose ID is 6.  
SQL > DELETE FROM CUSTOMERS  
WHERE ID =6; 
Now, the CUSTOMERS table would have the following records.  
 
+----+---------- +-----+----------- +---------- + 
| ID | NAME     | AGE | ADDRESS   | SALARY   |  
+----+---------- +-----+----------- +---------- + 
|  1 | Ramesh   |  32 | Ahmedabad |  2000.00 |  
|  2 | Khilan   |  25 | Delhi     |  1500.00 |  
|  3 | kaushik  |  23 | Kota      |  2000.00 |  
|  4 | Chaitali |  25 | Mumbai    |  6500.00 |  
|  5 | Hardik   |  27 | Bhopal    |  8500.00 |  
|  7 | Muffy    |  24 | Indore    | 10000.00 |  
+----+---------- +-----+----------- +---------- + 
If you want to DELETE all the records from the CUSTOMERS table, you do not need to use 
the WHERE clause and the DELETE query would be as follows −  
SQL > DELETE FROM CUSTOMERS ; 
Now, the CUSTOMERS table would not  have any record.  
 
2.8.10. Joins in SQL  
 
The SQL  Joins  clause is used to combine records from two or more tables in a database. A 
JOIN is a means for combining fields from two tables by using values common to each.  
Consider the following two tables −  
CUSTOMERS Table  
+----+---------- +-----+----------- +---------- + 
| ID | NAME     | AGE | ADDRESS   | SALARY   | 
+----+---------- +-----+----------- +---------- + 
|1|Ramesh |32|Ahmedabad |2000.00 | 
|2|Khilan |25|Delhi |1500.00 | 
|3| kaushik  |23|Kota |2000.00 | 
|4|Chaitali |25|Mumbai |6500.00 | 
|5|Hardik |27|Bhopal |8500.00 | 
|6|Komal |22| MP        |4500.00 | 
|7|Muffy |24|Indore |10000.00 | 
+----+---------- +-----+----------- +---------- + 
ORDERS Table  
+-----+--------------------- +------------- +-------- + 
|OID  | DATE                | CUSTOMER_ID | AMOUNT | 
+-----+--------------------- +------------- +-------- + 
|102|2009 -10-0800 :00:00|3|3000 | 
|100|2009 -10-0800 :00:00|3|1500 | 
|101|2009 -11-2000 :00:00|2|1560 | 
|103|2008 -05-2000 :00:00|4|2060 | 
+-----+--------------------- +------------- +-------- + 
Now, let us join these two tables in our SELECT statement as shown below.  
SQL > SELECT ID , NAME , AGE , AMOUNT  
   FROM CUSTOMERS , ORDERS  
   WHERE  CUSTOMERS .ID = ORDERS .CUSTOMER_ID ; 
This would produce the following result.  
+----+---------- +-----+-------- + 
| ID | NAME     | AGE | AMOUNT |  
+----+---------- +-----+-------- + 
|  3 | kaushik  |  23 |   3000 |  
|  3 | kaushik  |  23 |   1500 |  
|  2 | Khilan   |  25 |   156 0 | 
|  4 | Chaitali |  25 |   2060 |  
+----+---------- +-----+-------- + 
Here, it is noticeable that the join is performed in the WHERE clause. Several operators can be 
used to join tables, such as =, <, >, <>, <=, >=, !=, BETWEEN, LIKE, and NOT; they can all  be 
used to join tables. However, the most common operator is the equal to symbol.  
There are different types of joins available in SQL −  
• INNER JOIN  − returns rows when there is a match in both tables.  
• LEFT JOIN  − returns all rows from the left table, even if there are no matches in the 
right table.  
• RIGHT JOIN  − returns all rows from the right table, even if there are no matches in the 
left table.  
• FULL JOIN  − returns rows when there is a match in one of the tables.  
• SELF JOIN  − is used to join a table to itself as if the table were two tables, temporarily 
renaming at least one table in the SQL statement.  
• CARTESIAN JOIN  − returns the Cartesian product of the sets of records from the two or 
more joined tables.  
2.8.11. SET Operations in SQL  
SQL supports few Set operations which can be performed on the table data. These are used to get 
meaningful results from data stored in the table, under different special conditions.  
In this tutorial, we will c over 4 different types of SET operations, along with example:  
1. UNION  
2. UNION ALL  
3. INTERSECT  
4. MINUS  
UNION Operation  
UNION  is used to combine the results of two or more  SELECT  statements. However it will 
eliminate duplicate rows from its resultset. In case of uni on, number of columns and datatype 
must be same in both the tables, on which UNION operation is being applied.  
 
 
Example of UNION  
The First  table,  
ID Name  
1 abhi 
2 adam  
 
The Second  table,  
ID Name  
2 adam  
3 Chester  
 
Union SQL query will be,  
SELECT *FROMFirst  
UNION  
SELECT *FROMSecond ; 
The result set table will look like,  
ID NAME  

1 abhi 
2 Adam  
3 Chester  
 
 
UNION ALL  
This operation is similar to Union. But it also shows the duplicate rows.  
 
Example of Union All  
The First  table,  
ID 
NAME  
1 Abhi  
2 Adam  
 
The Second  table,  
ID NAME  
2 Adam  
3 Chester  
Union All query will be like,  
SELECT *FROMFirst  

UNIONALL  
SELECT *FROMSecond ; 
The resultset table will look like,  
ID NAME  
1 Abhi  
2 Adam  
2 Adam  
3 Chester  
INTERSECT  
Intersect operation is used to combine two  SELECT  statements, but it only retuns the records 
which are common from both  SELECT  statements. In case of  Intersect  the number of columns 
and datatype must be same.  
NOTE:  MySQL  does not support INTERSECT operator.  
 
Example of Intersect  
The First  table,  
ID NAME  
1 Abhi  
2 Adam  
The Second  table,  
ID NAME  
2 Adam  

3 Chester  
Intersect query will be,  
SELECT *FROMFirst  
INTERSECT  
SELECT *FROMSecond ; 
The result set table will look like 
ID NAME  
2 Adam  
MINUS: The Minus operation combines results of two  SELECT  statements and return only 
those in the final result, which belongs to the first set of the result.  
 
Example of Minus  
The First  table,  
ID NAME  
1 Abhi  
2 Adam  
The Second  table,  
ID NAME  
2 Adam  
3 Chester  
Minus query will be,  

SELECT *FROMFirst  
MINUS  
SELECT *FROMSecond ; 
The resultset table will look like,  
ID NAME  
1 Abhi  
 
2.8.12. SQL Cursors  
A cursor  is a pointer to this context area. PL/SQL controls the context area through a cursor. A 
cursor holds the rows (one or more) returned by a SQL statement. The set of rows the cursor 
holds is referred to as the  active set . 
You can name a cursor so that it could be referred to in a program to fetch and process the  rows 
returned by the SQL statement, one at a time. There are two types of cursors −  
• Implicit cursors  
• Explicit cursors  
Implicit Cursors  
Implicit cursors are automatically created by Oracle whenever an SQL statement is executed, 
when there is no explicit cursor for the statement. Programmers cannot control the implicit 
cursors and the information in it.  
Whenever a DML statement (INSERT, UPDATE and DELETE) is issued, an implicit cursor is 
associated with this statement. For INSERT operations, the c ursor holds the data that needs to 
be inserted. For UPDATE and DELETE operations, the cursor identifies the rows that would be 
affected.  
In PL/SQL, you can refer to the most recent implicit cursor as the  SQL cursor , which always 
has attributes such as  %FOU ND, %ISOPEN, %NOTFOUND , and  %ROWCOUNT . The 
SQL cursor has additional attributes,  %BULK_ROWCOUNT  and %BULK_EXCEPTIONS , 
designed for use with the  FORALL  statement. The following table provides the description of 
the most used attributes  
S.No  Attribute & Description  
1 %FOUND  
Returns TRUE if an INSERT, UPDATE, or DELETE statement affected one or more 
rows or a SELECT INTO statement returned one or more rows. Otherwise, it returns 
FALSE.  
2 %NOTFOUND  
The logical opposite of %FOUND. It returns TRUE if an INSERT, UPDATE, or 
DELETE statement affected no rows, or a SELECT INTO statement returned no 
rows. Otherwise, it returns FALSE.  
3 %ISOPEN  
Always returns FALSE for implicit cursors, because Oracle closes the SQL cursor 
automatically afte r executing its associated SQL statement.  
4 %ROWCOUNT  
Returns the number of rows affected by an INSERT, UPDATE, or DELETE 
statement, or returned by a SELECT INTO statement.  
Any SQL cursor attribute will be accessed as  sql%attribute_name  as shown below in the 
example.  
Example  
We will be using the CUSTOMERS table we had created and used in the previous chapters.  
Select * from customers;   
 
+----+---------- +-----+----------- +---------- +  
| ID | NAME     | AGE | ADDRESS   | SALARY   |  
+----+---------- +-----+----------- +---------- +  
|  1 | Ramesh   |  32 | Ahmedabad |  2000.00 |  
|  2 | Khilan   |  25 | Delhi     |  1500.00 |  
|  3 | kaushik  |  23 | Kota      |  2000.00 |  
|  4 | Chaitali |  25 | Mumbai    |  6500.00 |  
|  5 | Hardik   |  27 | Bhopal    |  8500.00 |  
|  6 | Komal    |  22 | MP        |  4500.00 |  
+----+---------- +-----+----------- +---------- + 
The following program will update the table and increase the salary of each custo mer by 500 
and use the  SQL%ROWCOUNT  attribute to determine the number of rows affected −  
DECLARE   
   total_rows number (2); 
BEGIN  
   UPDATE customers  
   SET salary = salary +500; 
   IF sql %notfound THEN  
      dbms_output .put_line ('no customers selected' ); 
   ELSIF sql %found THEN  
      total_rows := sql%rowcount ; 
      dbms_output .put_line ( total_rows ||' customers selected ' ); 
END  IF; 
END ; 
/ 
When the above code is executed at the SQL prompt, it produces the following result −  
6 customers selected   
PL/SQL procedure successfully completed.  
If you check the records in customers table, you will find that the rows have been updated −  
Select * from customers;   
+----+---------- +-----+----------- +---------- +  
| ID | NAME     | AGE |  ADDRESS   | SALARY   |  
+----+---------- +-----+----------- +---------- +  
|  1 | Ramesh   |  32 | Ahmedabad |  2500.00 |  
|  2 | Khilan   |  25 | Delhi     |  2000.00 |  
|  3 | kaushik  |  23 | Kota      |  2500.00 |  
|  4 | Chaitali |  25 | Mumbai    |  70 00.00 |  
|  5 | Hardik   |  27 | Bhopal    |  9000.00 |  
|  6 | Komal    |  22 | MP        |  5000.00 |  
+----+---------- +-----+----------- +---------- + 
Explicit Cursors  
Explicit cursors are programmer -defined cursors for gaining more control over the  context 
area . An explicit cursor should be defined in the declaration section of the PL/SQL Block. It is 
created on a SELECT Statement which returns more than one row.  
The syntax for creating an explicit cursor is −  
CURSOR cursor_name IS select_statement;  
Working with an explicit cursor includes the following steps −  
• Declaring the cursor for initializing the memory  
• Opening the cursor for allocating the memory  
• Fetching the cursor for retrieving the data  
• Closing the cursor to release the allocated memory  
 
 
Declaring the Cursor  
Declaring the cursor defines the cursor with a name and the associated SELECT statement. For 
example −  
CURSOR c_customers IS  
   SELECT id , name , address FROM customers ; 
Opening the Cursor  
Opening the cursor allocates the memory for the cursor and makes it ready for fetching the rows 
returned by the SQL statement into it. For example, we will open the above defined cursor as 
follows −  
OPEN c_customers ; 
Fetching the Cursor  
Fetching the cursor involves accessing one row at a time. For e xample, we will fetch rows from 
the above -opened cursor as follows −  
FETCH c_customers INTO c_id , c_name , c_addr ; 
Closing the Cursor  
Closing the cursor means releasing the allocated memory. For example, we will close the 
above -opened cursor as follows −  
CLOSE c_customers ; 
Example  
Following is a complete example to illustrate the concepts of explicit cursors &minua;  
DECLARE  
   c_id customers .id%type; 
   c_name customer .name %type; 
   c_addr customers .address %type; 
   CURSOR c_customers is 
      SELECT id , name , address FROM customers ; 
BEGIN  
   OPEN c_customers ; 
   LOOP  
   FETCH c_customers into c_id, c_name , c_addr ; 
      EXIT WHEN c_customers %notfound ; 
      dbms_output .put_line (c_id ||' '|| c_name ||' '|| c_addr ); 
END  LOOP ; 
   CLOSE c_customers ; 
END ; 
/ 
When the above code is executed at the SQL prompt, it produces the following result −  
1 Ramesh Ahmedabad   
2 Khilan Delhi   
3 kaushik Kota      
4 Chaitali Mumbai   
5 Hardik Bhopal    
6 Komal MP   
 
2.8.13. Triggers in SQL  
Triggers are stored programs, which are automatically executed or fired when some events 
occur. Triggers are, in fact, written to be executed in response to any of the following events −  
• A database manipulation (DML)  statement (DELETE, INSERT, or UPDATE)  
• A database definition (DDL)  statement (CREATE, ALTER, or DROP).  
• A database operation  (SERVERERROR, LOGON, LOGOFF, STARTUP, or 
SHUTDOWN).  
Triggers can be defined on the table, view, schema, or database with which the event is 
associated.  
Benefits of  Triggers  
Triggers can be written for the following purposes −  
• Generating some derived column values automatically  
• Enforcing referential integrity  
• Event logging and storing information on table access  
• Auditing  
• Synchronous replication of tables  
• Imposing sec urity authorizations  
• Preventing invalid transactions  
Creating Triggers  
The syntax for creating a trigger is −  
CREATE [OR REPLACE ] TRIGGER trigger_name   
{BEFORE | AFTER | INSTEAD OF } 
{INSERT [OR]| UPDATE [OR]| DELETE } 
[OF col_name ] 
ON table_name   
[REFERENCING OLD AS o NEW AS n ] 
[FOR EACH ROW ] 
WHEN (condition ) 
DECLARE  
Declaration -statements  
BEGIN  
Executable -statements  
EXCEPTION  
Exception -handling -statements  
END ; 
Where,  
• CREATE [OR REPLACE] TRIGGER trigger_name − Creates or replaces an existing 
trigger with the  trigger_name . 
• {BEFORE | AFTER | INSTEAD OF} − This specifies when the trigger will be executed. 
The INSTEAD OF clause is used for creating trigger on a view.  
• {INSERT [OR] | UPDATE [OR] | DELETE} − This specifies the DML operation.  
• [OF col_name] − This specifies the column name that will be updated.  
• [ON table_name] − This specifies the name of the table associated with the trigger.  
• [REFERENCING OLD AS o NEW AS n] − This allows you to refer new and old values 
for various DM L statements, such as INSERT, UPDATE, and DELETE.  
• [FOR EACH ROW] − This specifies a row -level trigger, i.e., the trigger will be executed 
for each row being affected. Otherwise the trigger will execute just once when the SQL 
statement is executed, which is  called a table level trigger.  
• WHEN (condition) − This provides a condition for rows for which the trigger would fire. 
This clause is valid only for row -level triggers.  
Example  
To start with, we will be using the CUSTOMERS table we had created and used in the previous 
chapters −  
Select * from customers;   
 
+----+---------- +-----+----------- +---------- +  
| ID | NAME     | AGE | ADDRESS   | SALARY   |  
+----+---------- +-----+----------- +---------- +  
|  1 | Ramesh   |  32 | Ahmedabad |  2000.00 |  
|  2 | Khila n   |  25 | Delhi     |  1500.00 |  
|  3 | kaushik  |  23 | Kota      |  2000.00 |  
|  4 | Chaitali |  25 | Mumbai    |  6500.00 |  
|  5 | Hardik   |  27 | Bhopal    |  8500.00 |  
|  6 | Komal    |  22 | MP        |  4500.00 |  
+----+---------- +-----+----------- +---------- +  
The following program creates a  row-level  trigger for the customers table that would fire for 
INSERT or UPDATE or DELETE operations performed on the CUSTOMERS table. This 
trigger will display the salary difference between the old values  and new values −  
CREATE OR REPLACE TRIGGER display_salary_changes  
BEFORE DELETE OR INSERT OR UPDATE ON customers  
FOR EACH ROW  
WHEN (NEW .ID >0) 
DECLARE  
   sal_diff number ; 
BEGIN  
   sal_diff :=:NEW .salary  -:OLD .salary ; 
   dbms_output .put_line ('Old salary: ' ||:OLD .salary ); 
   dbms_output .put_line ('New salary: ' ||:NEW .salary ); 
   dbms_output .put_line ('Salary difference: ' || sal_diff ); 
END ; 
/ 
When the above code is executed at the SQL prompt, it produces the following result −  
Trigger created.  
The foll owing points need to be considered here −  
• OLD and NEW references are not available for table -level triggers, rather you can use 
them for record -level triggers.  
• If you want to query the table in the same trigger, then you should use the AFTER 
keyword, because triggers can query the table or change it again only after the initial 
changes are applied and the table is back in a consistent state.  
• The above trigger has been written in such a way that it will fire before any DELETE or 
INSERT or UPDAT E operation on the table, but you can write your trigger on a single 
or multiple operations, for example BEFORE DELETE, which will fire whenever a 
record will be deleted using the DELETE operation on the table.  
Triggering a Trigger  
Let us perform some DML operations on the CUSTOMERS table. Here is one INSERT 
statement, which will create a new record in the table −  
INSERT INTO CUSTOMERS (ID,NAME ,AGE ,ADDRESS ,SALARY ) 
VALUES (7,'Kriti' ,22,'HP',7500.00 ); 
When a record is created in the CUSTOMERS table, the above create 
trigger,  display_salary_changes  will be fired and it will display the following result −  
Old salary:  
New salary: 7500  
Salary difference:  
Because this is a new record, old salary is not available and the above result comes as null. Let 
us now  perform one more DML operation on the CUSTOMERS table. The UPDATE statement 
will update an existing record in the table −  
UPDATE customers  
SET salary = salary +500 
WHERE id =2; 
When a record is updated in the CUSTOMERS table, the above create 
trigger,  display_salary_changes  will be fired and it will display the following result −  
Old salary: 1500  
New salary: 2000  
Salary difference: 500  
2.8.14. PL/SQL Procedures  
A subprogram  is a program unit/module that performs a particular task. These subprograms 
are combined to form larger programs. This is basically called the 'Modular design'. A 
subprogram can be invoked by another subprogram or program which is called the  calling 
program . 
A subprogram can be created −  
• At the schema level  
• Inside a pa ckage  
• Inside a PL/SQL block  
At the schema level, subprogram is a  standalone subprogram . It is created with the CREATE 
PROCEDURE or the CREATE FUNCTION statement. It is stored in the database and can be 
deleted with the DROP PROCEDURE or DROP FUNCTION state ment.  
A subprogram created inside a package is a  packaged subprogram . It is stored in the database 
and can be deleted only when the package is deleted with the DROP PACKAGE statement. We 
will discuss packages in the chapter  'PL/SQL - Packages' . 
PL/SQL subp rograms are named PL/SQL blocks that can be invoked with a set of parameters. 
PL/SQL provides two kinds of subprograms −  
• Functions  − These subprograms return a single value; mainly used to compute and 
return a value.  
• Procedures  − These subprograms do not r eturn a value directly; mainly used to perform 
an action.  
This chapter is going to cover important aspects of a  PL/SQL procedure . We will 
discuss  PL/SQL function  in the next chapter.  
Parts of a PL/SQL Subprogram  
Each PL/SQL subprogram has a name, and may a lso have a parameter list. Like anonymous 
PL/SQL blocks, the named blocks will also have the following three parts −  
S.No  Parts & Description  
1 Declarative Part  
It is an optional part. However, the declarative part for a subprogram does not start with the 
DECLARE keyword. It contains declarations of types, cursors, constants, variables, 
exceptions, and nested subprograms. These items are local to the subprogram and cease to 
exist when the subprogram completes execution.  
2 Executable Part  
This is a mand atory part and contains statements that perform the designated action.  
3 Exception -handling  
This is again an optional part. It contains the code that handles run -time errors.  
Creating a Procedure  
A procedure is created with the  CREATE OR REPLACE PROCEDURE  statement. The 
simplified syntax for the CREATE OR REPLACE PROCEDURE statement is as follows −  
CREATE [OR REPLACE ] PROCEDURE procedure_name  
[(parameter_name [IN | OUT | IN OUT ] type [,...])]  
{IS | AS} 
BEGIN  
< procedure_body > 
END  procedure_name ; 
Where,  
• procedure -name  specifies the name of the procedure.  
• [OR REPLACE] option allows the modification of an existing procedure.  
• The optional parameter list contains name, mode and types of the 
parameters.  IN represents the value that will be passed from outside and OUT represents 
the parameter that will be used to return a value outside of the procedure.  
• procedure -body  contains the executable part.  
• The AS keyword is used instead of the IS keyword for creating a standalone procedure.  
Example  
The following example creates a simple procedure that displays the string 'Hello World!' on the 
screen when executed.  
CREATE OR REPLACE PROCEDURE greetings  
AS  
BEGIN  
   dbms_output .put_line ('Hello World!' ); 
END ; 
/ 
When the above code is executed using the SQL prompt, it will produce the following result −  
Procedure created.  
Executing a Standalone Procedure  
A standalone procedure can be called in two ways −  
• Using the  EXECUTE  keyword  
• Calling the name of the procedure from a PL/SQL block  
The above pr ocedure named  'greetings'  can be called with the EXECUTE keyword as −  
EXECUTE greetings;  
The above call will display −  
Hello World  
 
PL/SQL procedure successfully completed.  
The procedure can also be called from another PL/SQL block −  
BEGIN  
   greetings ; 
END ; 
/ 
The above call will display −  
Hello World   
 
PL/SQL procedure successfully completed.  
Deleting a Standalone Procedure  
A standalone procedure is deleted with the  DROP PROCEDURE  statement. Syntax for 
deleting a procedure is −  
DROP PROCEDUR E procedure -name;  
You can drop the greetings procedure by using the following statement −  
DROP PROCEDURE greetings;  
Parameter Modes in PL/SQL Subprograms  
The following table lists out the parameter modes in PL/SQL subprograms −  
S.No  Parameter Mode & Description  
1 IN 
An IN parameter lets you pass a value to the subprogram.  It is a read -only parameter . 
Inside the subprogram, an IN parameter acts like a constant. It cannot be assigned a value. 
You can pass a constant, literal, initialized variable, or expression as an IN parameter. You 
can also initialize it to a default value; however, in that case, it is omitted from the 
subprogram call.  It is the default mode of parameter passing. Parameters are passed by 
reference . 
2 OUT  
An OUT paramet er returns a value to the calling program. Inside the subprogram, an OUT 
parameter acts like a variable. You can change its value and reference the value after 
assigning it.  The actual parameter must be variable and it is passed by value . 
3 IN OUT  
An IN OUT  parameter passes an initial value to a subprogram and returns an updated value 
to the caller. It can be assigned a value and the value can be read.  
The actual parameter corresponding to an IN OUT formal parameter must be a variable, not 
a constant or a n expression. Formal parameter must be assigned a value.  Actual parameter 
is passed by value.  
 
IN & OUT Mode Example 1  
This program finds the minimum of two values. Here, the procedure takes two numbers using 
the IN mode and returns their minimum using the OUT parameters.  
DECLARE  
   a number ; 
   b number ; 
   c number ; 
PROCEDURE findMin (x IN number , y IN number , z OUT number ) IS  
BEGIN  
   IF x < y THEN  
      z:= x; 
   ELSE  
      z:= y; 
END  IF; 
END ; 
BEGIN  
   a:=23; 
   b:=45; 
   findMin (a, b, c); 
   dbms_output .put_line (' Minimum of (23, 45) : ' || c); 
END ; 
/ 
When the above code is executed at the SQL prompt, it produces the following result −  
Minimum of (23, 45) : 23   
PL/SQL procedure successfully completed.  
IN & OUT Mode Example 2  
This procedure computes the square of value of a passed value. This example shows how we 
can use the same parameter to accept a value and then return another result.  
DECLARE  
   a number ; 
PROCEDURE squareNum (x IN OUT number ) IS  
BEGIN  
  x := x * x; 
END ; 
BEGIN  
   a:=23; 
   squareNum (a); 
   dbms_output .put_line (' Square of (23): ' || a); 
END ; 
/ 
When the above code is executed at the SQL prompt, it produces the following result −  
Square of (23) : 529  
 
PL/SQL procedure successfully completed.  
Methods for Passing Parameters  
Actual parameters can be passed in three ways −  
• Positional notation  
• Named notation  
• Mixed notation  
Positional Notation  
In positional notation, you can call the procedure as −  
findMin(a, b, c, d);  
In positional notation, the first actual parameter is substituted for the first formal parameter; the 
second actual parameter is substituted for the second formal parameter, and so on. So,  a is 
substituted for  x, b is substituted for  y, c is substituted for  z and d is substituted for  m. 
Named Notation  
In named notation, the actual parameter is associated with the formal parameter using the  arrow 
symbol ( => ) . The procedure call will be like the following −  
findMin(x => a , y => b, z => c, m => d);  
Mixed Notation  
In mixed notation, you can mix both notations in procedure call; however, the positional 
notation should precede the named notation.  
The following call is legal −  
findMin(a, b, c, m => d);  
However, this is not lega l: 
findMin(x => a, b, c, d);  
 
 
 
 
 
 
 
 
 
 
 
 
 
IMPORTANT QUESTIONS  
 
1. Q.1 Consider the relational database:  
EMPLOYEE (Name, Ssn, Sex, Superssn, Dno)  
DEPARTMENT ( Dnumber , Dname, Dlocation)  
DEPT_LOCATION ( Dnumber,Dlocation ) 
PROJECT (Pname, Pnumber , Plocation, Dnum)  
WORKS_ON ( Essn, Pno , Hours)  
DEPENDENT ( ESSN, Dependent_name , Sex, Bdate, Relationship)  
Write the SQL expressions for the following queries  
i.Retrieve the name and address of all employees who work for research department.  
ii.Retrieve the n ame of employees who have no dependents  
iii.List the name of employees who have atleast one dependent.  
2. Discuss the entity integrity and referential integrity constraints. Why each is considered 
important ? 
3. What is union compatibility? Why do union, intersection and difference operations 
require that the relations on which they applied be union compatible?  
4. Explain tuple relational calculus and domain relational calculus by taking suitable 
example . 
5. Write  Relational Algebraic Expressions for the followi ng: 
i. Department (Deptid, Dname, HOD)  
ii. Student (Rollno, Name, Year, Deptid)  
iii. Project (Pid, Pname, Duration)  
iv. Student_PROJECT (Rollno, Pid)  
Display roll numbers of those students who have not been assigned any project.  
Display student names along with their depa rtment names.  
Display names of those students who have been assigned project of less than 15 days 
duration . 
6. Consider the following relational schema:  
SUPPLIER (SID , SNAME, SADDRESS)   
PARTS ( PID, PNAME, COLOR)   
CATALOG ( SID, PID , COST),  
The catalog relation lists the prices charged for parts by suppliers:  
Express the following statements into relational algebra expressions  
Find the name of a supplier who supplies yellow parts.  
Find the names of the suppliers who supply red part that costs less than 100 dollars.  
Find the names of the suppliers who supply a red part that costs more than 100 dollars 
and a green part that costs less than 100 dollars.  
Find the name of the supplier and id who supply green part and address is Noida.  
7. Define R elational calculus and their types. Explain it with suitable examples.  
8. Discuss Join and types with suitable example.  
9. What do you mean by referential integrity? Explain the concept of foreign key with a 
suitable example?  
10. What are the differences in Cartesia n product and natural join operations? Explain with a 
suitable example.                                                                                                                                                       
 
 
 
 
 
 
 
 
 
 
